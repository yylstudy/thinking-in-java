package d.polymorphism;

/**
 * 父类和子类都有共同属性时，在使用多态时，会使用父类的属性
 * f.x 是使用父类的值，尽管实际上这是一个son对象，但是test方法调用的实际上还是son对象而不是Father的，这是因为
 * 方法进行了后期绑定或叫动态绑定，它意味着绑定在运行期间进行，以对象的类型为基础。后期绑定也叫作“动
 * 态绑定”或“运行期绑定”。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象
 * 的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去
 * 调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：
 * 它们都要在对象中安插某些特殊类型的信息
 * Java 中绑定的所有方法都采用后期绑定技术，这和对象属性还是有区别的，对象属性没有后期绑定的说法，
 * 所以使用多态时就是调用父类的属性
 * 总结：多态调用方法时，由于使用后期绑定，所以调用的实际上还是真正new的对象，而不是它的上塑造型，但是
 * 属性没有动态绑定
 * @author yyl-pc
 *
 */
public class MyTest2 {
	public static void main(String[] args) {
		Father father = new Son();
		System.out.println(father.s);
		father.method();
	}
}
